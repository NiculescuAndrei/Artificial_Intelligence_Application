\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{url}

\title{Algoritm de c\u{a}utare euristic\u{a} (A*)  \\
\large{grupa CR 2.2B, an 2, al 2-lea semestru, Calculatoare Rom\^{a}n\u{a}}}
\author{Niculescu Marius-Andrei }
\date{\today}

\begin{document}

\maketitle


\newpage

\tableofcontents

\newpage

\section{Enun\c{t}ul problemei}

S\u{a} presupunem c\u{a} doi prieteni locuiesc \^{i}n diferite ora\c{s}e pe o hart\u{a}. La fiecare pas, putem muta simultan fiecare prieten \^{i}ntr-un ora\c{s} vecin de pe hart\u{a}. Timpul necesar pentru a trece de la ora\c{s}ul i la ora\c{s}ul vecin j este egal cu lungimea drumului d(i, j) dintre cele 2 ora\c{s}e, dar la fiecare pas prietenul care ajunge primul trebuie s\u{a} a\c{s}tepte p\^{a}n\u{a} c\^{a}nd \c{s}i cel\u{a}lalt prieten ajunge (\c{s}i \^{i}l sun\u{a} pe primul pe telefonul s\u{a}u mobil) \^{i}nainte ca urm\u{a}toarea tur\u{a} s\u{a} poat\u{a} \^{i}ncepe. Vrem ca cei doi prieteni s\u{a} se \^{i}nt\^{a}lneasc\u{a} c\^{a}t mai repede posibil. 

\begin{itemize}
    \item [a.]
    Scrie\c{t}i o formulare detaliat\u{a} pentru aceast\u{a} problem\u{a} de c\u{a}utare.
    \item [b.]
    Identifica\c{t}i un algoritm de c\u{a}utare pentru aceast\u{a} sarcin\u{a} \c{s}i explica\c{t}i alegerea dumneavoastr\u{a}.
\end{itemize}

\section{Algoritm}
\begin{tabbing}
A*($sursa$, $destinatie$, $graf$) \\
1. $lista\_deschisa$ = \{$sursa$\} \\
2. $lista\_inchisa$ = \{\} \\
3. {\bf pentru fiecare} \=nod in graf {\bf executa}\\
4.                        \> $calculeazaHCost$($nod$) \\
5. $parinte(sursa)$ = $null$ \\
6. $g\_cost(sursa)$ = 0 \\
7. $f\_cost(sursa)$ = $h\_cost(sursa)$ \\
8. {\bf atata timp cat} \=$lista\_deschisa$ nu este goala {\bf executa}\\
9.                       \>$curent$ = nodul din lista deschisa cu f\_cost minim \\
10.                      \>{\bf daca} \=$curent$ = $destinatie$ {\bf executa}\\
11.                      \>             \>break \\
12.                      \> scoate $curent$ din $lista\_deschisa$ \\
13.                      \> adauga $curent$ in $lista\_inchisa$ \\
14.                      \> {\bf pentru fiecare} \=vecin al nodului $curent$ {\bf executa} \\
15.                      \>                        \>$noulGCost$ = $g\_cost(curent)$ + d($curent$,$vecin$)\\
16.                      \>                        \>$noulFCost$ = $h\_cost(vecin)$ + $noulGCost$ \\
17.                      \>                        \>{\bf daca} \=$vecin \in lista\_inchisa$ si $noulFCost>=f\_cost(vecin)$  \\
18.                      \>                        \>             \>continua \\
19.                      \>                        \>{\bf altfel daca} \=$vecin \notin lista\_deschisa$ sau $noulFCost<f\_cost(vecin)$ \\
20.                      \>                        \>                    \>$parinte(vecin)$ = $curent$ \\
21.                      \>                        \>                    \>$g\_cost(vecin)$ = $noulGCost$\\
22.                      \>                        \>                    \>$f\_cost(vecin)$ = $noulFCost$\\
23.                      \>                        \>                    \>{\bf daca} \=$vecin \in lista\_deschisa$ \\
24.                      \>                        \>                    \>             \>scoate $vecin$ din $lista\_deschisa$ \\
25.                      \>                        \>                    \>adauga $vecin$ in $lista\_deschisa$ \\
\end{tabbing}

\newpage

La \^{i}nceputul algoritmului consider\u{a}m 2 liste. O list\u{a} care con\c{t}ine mul\c{t}imea nodurilor ce pot fi explorate (lista deschis\u{a}) \c{s}i o list\u{a} care \c{t}ine cont de nodurile care au fost deja vizitate (lista \^{i}nchis\u{a}). \^{I}n lista deschis\u{a} introducem prima dat\u{a} nodul surs\u{a}. Dup\u{a} acest lucru, cu ajutorul func\c{t}iei euristice ata\c{s}\u{a}m fiec\u{a}rui nod un cost aproximativ al c\u{a}ii p\^{a}n\u{a} la nodul destina\c{t}ie. Acest lucru l-am realizat cu ajutorul algoritmului Bellman Ford aplicat asupra nodului destina\c{t}ie. \^{I}n urma execu\c{t}iei algoritmului, \^{i}n fiecare nod se va re\c{t}ine distan\c{t}a minim\u{a} de la nodul destina\c{t}ie c\u{a}tre sine. Am considerat func\c{t}ia euristic\u{a} ca fiind 3/4 din valoarea ob\c{t}inut\u{a} \^{i}n urma aplic\u{a}rii algoritmului Bellman Ford. \^{I}n continuare ini\c{t}ializez p\u{a}rintele nodului surs\u{a} ca fiind null iar $f\_cost$ ca fiind valoarea aproximativ\u{a} a drumului minim p\^{a}n\u{a} la destina\c{t}ie($h\_cost$). At\^{a}ta timp c\^{a}t lista deschis\u{a} con\c{t}ine noduri, vom extrage de fiecare dat\u{a} nodul cu $f\_cost$ minim. \^{I}n cazul \^{i}n care acesta este chiar nodul destina\c{t}ie, algoritmul se \^{i}ncheie. Altfel, scoatem nodul din lista deschis\u{a} \c{s}i \^{i}l marc\u{a}m ca vizitat, prin ad\u{a}ugarea acestuia \^{i}n lista \^{i}nchis\u{a}. Parcurgem vecinii nodului curent \c{s}i pentru fiecare calcul\u{a}m $noulGCost$ ca fiind costul g al nodului curent plus valoarea muchiei care leag\u{a} nodurile. $noulFCost$ va fi suma dintre $noulGCost$ \c{s}i costul h al nodului vecin. \^{I}n cazul \^{i}n care nodul vecin se afl\u{a} \^{i}n lista \^{i}nchis\u{a} \c{s}i $noulFCost$ este mai mare sau egal dec\^{a}t costul f al nodului vecin nu facem nimic. Dac\u{a} nodul vecin nu se afl\u{a} \^{i}n lista deschis\u{a} sau dac\u{a} $noulFCost$, calculat anterior, este mai mic dec\^{a}t costul f al nodului vecin atunci p\u{a}rintele nodului vecin va fi nodul curent \c{s}i actualiz\u{a}m costul g si f al nodului vecin cu $noulGCost$ \c{s}i $noulFCost$. Dac\u{a} nodul vecin se afl\u{a} \^{i}n lista deschis\u{a} atunci \^{i}l scoatem pentru a evita ad\u{a}ugarea acestuia de 2 ori.
 
 \section{Date experimentale}

Pentru a genera datele de intrare m-am folosit de clasa RandomMapGenerator. Deoarece fiecare nod trebuie s\u{a} aib\u{a} un nume diferit, am utilizat libr\u{a}ria JavaFaker cu ajutorul c\u{a}reia pot s\u{a} apelez o func\c{t}ie pentru a-mi genera un nume aleator pentru ora\c{s}e. \^{I}n aceast\u{a} clas\u{a}, mai am 2 variabile $numberOfCities$ \c{s}i $numberOfRoads$ pe care le ini\c{t}ializez \^{i}n urma citrii valorilor din fi\c{s}ierele de input. Clasa con\c{t}ine $getRandomIntegerBetweenRange(double min, double max)$, o func\c{t}ie care returneaz\u{a} un num\u{a}r \^{i}ntreg aleator din intervalul [min,max]. Func\c{t}ia principal\u{a} din aceast\u{a} clas\u{a} care realizeaz\u{a} crearea \^{i}n mod aleatoriu a h\u{a}r\c{t}ii cu ora\c{s}e este $mapGenerator$. Dup\u{a} ce se execut\u{a}, aceast\u{a} func\c{t}ie returneaz\u{a} o list\u{a} cu nodurile care alc\u{a}tuiesc harta \c{s}i \^{i}n mod implicit \c{s}i drumurile dintre acestea. Prima dat\u{a} \^{i}n aceast\u{a} func\c{t}ie creez un HashMap \^{i}n care stochez ora\c{s}e al c\u{a}ror nume \^{i}l generez cu ajutorul func\c{t}iei $faker.address().city()$. \^{I}n cazul \^{i}n care aceast\u{a} func\c{t}ie genereaz\u{a} un nume care se g\u{a}seste deja \^{i}n HashMap, \^{i}n interiorul unui while se va genera un alt nume p\^{a}n\u{a} c\^{a}nd acesta nu se afl\u{a} in HashMap. Pentru a avea posibilitatea de a accesa noduri de pe pozi\c{t}ii alese \^{i}n mod aleator, voi crea un ArrayList \^{i}n care voi pune nodurile din HashMap, atribuind variabilei $name$ din $Node$, valoarea cheii corespunz\u{a}toare nodului din HashMap. Prima dat\u{a}, pentru a m\u{a} asigura c\u{a} din orice nod pot ajunge \^{i}n toate celelalte, am construit un drum \^{i}ntre nodul 0 \c{s}i 1, 1 \c{s}i 2, ..., $numberOfCities-1$ \c{s}i $numberOfCities$. Deci $numberOfCities-1$ muchii sunt rezervate pentru a m\u{a} asigura c\u{a} graful este conectat. \^{I}n continuare, cu restul muchiilor generez aleator pozi\c{t}ii din lista de noduri p\^{a}n\u{a} ob\c{t}in 2 noduri diferite. Dac\u{a} exist\u{a} o muchie \^{i}ntre acestea nu fac nimic, iar dac\u{a} nu exist\u{a} creez una. Pentru a ata\c{s}a un cost muchiilor, m\u{a} folosesc de func\c{t}ia $getRandomIntegerBetweenRange(double min, double max)$. Pentru cele 10 teste am considerat costul muchiilor ca fiind \^{i}n intervalul [50,500]. La final returnez lista de noduri care con\c{t}ine implicit \c{s}i drumurile .

\section{Proiectarea aplica\c{t}iei experimentale}
\subsection{Structura de nivel \^{i}nalt a aplica\c{t}iei}
\begin{itemize}
    \item Node.java
    \item Edge.java
    \item RandomMapGenerator.java
    \item BellmanFord.java 
    \item AStar.java
    \item CalculateTime.java
    \item Application.java
\end{itemize}
\subsection{Descrierea mul\c{t}imii datelor de intrare}
Se cite\c{s}te dintr-un fi\c{s}ier num\u{a}rul de noduri \c{s}i num\u{a}rul de muchii din graful neorientat, iar apoi ini\c{t}ializez variabilele $numberOfCities$ \c{s}i $numberOfRoads$, din clasa $RandomMapGenerator$, cu valorile citite din fi\c{s}ier \c{s}i generez harta cu ora\c{s}e.

\subsection{Descrierea ie\c{s}irilor / rezultatelor}
Datele de ie\c{s}ire din fi\c{s}ier men\c{t}ioneaz\u{a} num\u{a}rul de ora\c{s}e \c{s}i de drumuri de pe hart\u{a}, pozi\c{t}iile celor 2 prieteni, nodurile care au fost vizitate \c{s}i num\u{a}rul acestora \^{i}n procesul de a determina cel mai scurt drum pe care s\u{a} se \^{i}nt\^{a}lneasc\u{a} cei 2 prieteni, calea final\u{a} cu cost minim pe care s\u{a} se \^{i}nt\^{a}lneasc\u{a} \^{i}n cel mai scurt timp posibil, ora\c{s}ul \^{i}n care se vor \^{i}nt\^{a}lni \c{s}i timpii de execu\c{t}ie ai algoritmului A* \c{s}i a \^{i}ntregului program.

\newpage

\subsection{Modulele aplica\c{t}iei}
Aplica\c{t}ia are urm\u{a}toarele module:
\begin{itemize}
    \item 10 fi\c{s}iere de tip text din care se citesc num\u{a}rul de noduri \c{s}i de muchii care intervin \^{i}n construirea \^{i}n mod aleator a ora\c{s}ului. Fiecare fi\c{s}ier contribuie la ob\c{t}inerea unui test unic.
    \item 10 fi\c{s}iere de tip text \^{i}n care sunt scrise datele de iesire men\c{t}ionate \^{i}n subsec\c{t}iunea de mai sus.
    \item Node.java \^{i}n care se definesc atributele unui nod(ora\c{s}) din graf(hart\u{a}). Fiecare nod con\c{t}ine o list\u{a} de drumuri (cu tot cu costul lor) c\u{a}tre ora\c{s}ele vecine cu care se conecteaz\u{a} (aceste drumuri se adaug\u{a} cu ajutorul func\c{t}iei $addNeighbour$($Node$ $neighbour$, $int$ $cost$) care construie\c{s}te un drum \^{i}ntre nodul curent \c{s}i cel dat ca parametru func\c{t}iei) , un p\u{a}rinte \^{i}n cazul \^{i}n care nodul intervine \^{i}n calea final\u{a} de cost minim pe care cei 2 prieteni se \^{i}nt\^{a}lnesc \^{i}n cel mai scurt timp, variabila $cost$ care \^{i}n urma execu\c{t}iei algoritmului BellmanFord este actualizat\u{a} \c{s}i va reprezenta distan\c{t}a minim\u{a} p\^{a}n\u{a} la nodul pentru care s-a aplicat algoritmul, variabila $g\_cost$ care contorizeaz\u{a} costul de p\^{a}n\u{a} acum pentru a ajunge la destina\c{t}ie, variabila $f\_cost$ care reprezint\u{a} costul estimat total al c\u{a}ii prin nodul curent \c{s}i variabila $h\_cost$ care reprezint\u{a} o estimare a costului drumului de la nodul curent p\^{a}n\u{a} la destina\c{t}ie. Aceast\u{a} variabil\u{a} este ini\c{t}ializat\u{a} cu ajutorul func\c{t}iei $setHCost()$, prin intermediul c\u{a}reia am considerat ca $h\_cost$ s\u{a} fie $cost$ - $cost/4$.
    \item Edge.java este clasa care define\c{s}te atributele unei muchii din graf. Aceasta are un cost, \c{s}i o variabil\u{a} $target$, care reprezint\u{a} al doilea nod cu care se leag\u{a} primul atunci c\^{a}nd se apeleaz\u{a} func\c{t}ia $addNeighbour$. 
    \item RandomMapGenerator.java este clasa pe care am descris-o \^{i}n sec\c{t}iunea 3 "Date experimentale".
    \item BellmanFord.java reprezint\u{a} clasa care execut\u{a} algoritmul BellmanFord pentru a afla distan\c{t}a minim\u{a} a tuturor nodurilor p\^{a}n\u{a} la un nod selectat. Aceast\u{a} distan\c{t}\u{a} o voi folosi \^{i}n func\c{t}ia euristic\u{a} pentru a determina variabila $h\_cost$.
    \item AStar.java este clasa care execut\u{a} algoritmul A* pentru a determina drumul pe care cei 2 prieteni se vor \^{i}nt\^{a}lni \^{i}n cel mai scurt timp.
    \item CalculateTime.java este clasa care se folose\c{s}te de drumul aflat de A* pentru a determina ora\c{s}ul \^{i}n care se vor \^{i}nt\^{a}lni \c{s}i timpul scurs p\^{a}n\u{a} se va \^{i}nt\^{a}mpla acest lucru. Timpul se calculeaz\u{a} adun\^{a}nd, la fiecare tur\u{a}, la timpul total, maximul dintre distan\c{t}a parcurs\u{a} de primul prieten p\^{a}n\u{a} la un ora\c{s} vecin \c{s}i distan\c{t}a parcurs\u{a} de cel de-al doilea prieten.
    \item Application.java este clasa \^{i}n care testez toate celelalte func\c{t}ii. Aici realizez citirea din fi\c{s}ierele de input, generez \^{i}n mod aleator harta cu ora\c{s}ele, aplic BellmanFord pe nodul desemnat de una din pozi\c{t}iile celor 2 prieteni, aplic A* av\^{a}nd ca nod surs\u{a} \c{s}i destina\c{t}ie, pozi\c{t}iile celor 2 prieteni, dup\u{a} care apelez func\c{t}ia $calculateTime$ pentru a determina timpul \^{i}n care se vor \^{i}nt\^{a}lni.
\end{itemize}

\subsection{Func\c{t}iile aplica\c{t}iei}
Aplica\c{t}ia are urm\u{a}toarele func\c{t}ii:
\begin{itemize}
    \item $bellmanFord$($Node$ $source$, $List<Node> nodeList$) reprezint\u{a} func\c{t}ia care implementeaz\u{a} algoritmul Bellman Ford. Prima dat\u{a} consider\u{a}m costul nodului surs\u{a} ca fiind 0 pentru ca algoritmul s\u{a} \^{i}nceap\u{a} de la acesta. Consider\u{a}m o bucl\u{a} for cu $nodeList.size() - 1$ itera\c{t}ii deoarece ne propunem s\u{a} relax\u{a}m muchia dintr-o cale cu o singur\u{a} muchie, dup\u{a} muchiile dintr-o cale cu 2 muchii, p\^{a}n\u{a} c\^{a}nd ajungem la c\u{a}i cu $nodeList.size() - 1$ muchii. $nodeList.size() - 1$ reprezint\u{a} lungimea maxim\u{a} a c\u{a}ii minime dintr-un graf, dac\u{a} acesta nu are cicluri (\^{i}n acest caz nu are). Dup\u{a} trebuie s\u{a} parcurgem lista cu noduri din graf, iar pentru fiecare nod s\u{a} parcurgem lista cu muchii. Dac\u{a} costul ata\c{s}at nodului curent plus distan\c{t}a de la nodul curent la vecin este mai mic dec\^{a}t costul ata\c{s}at nodului vecin, atunci "relax\u{a}m" muchia \c{s}i ata\c{s}\u{a}m noul cost nodului vecin.
    \item $AStarSearch$($Node$ $source$, $Node$ $destination$, $List<Node> nodeList$, $BufferedWriter$ $writer$) reprezint\u{a} func\c{t}ia care implementeaz\u{a} algoritmul A*. Prima dat\u{a} pentru fiecare nod de pe hart\u{a}, apel\u{a}m func\c{t}ia $setHCost()$ pentru a ini\c{t}ializa $h\_cost$ ca fiind 3/4 din $cost$ al fiec\u{a}rui nod care a fost determinat \^{i}n urma algoritmului Bellman Ford. Dup\u{a} aceea, ini\c{t}ializ\u{a}m p\u{a}rintele nodului surs\u{a} ca fiind null, $g\_cost$ al nodului surs\u{a} ca fiind 0 \c{s}i $f\_cost$ ca fiind egal cu $h\_cost$ deoarece $g\_cost$ este 0. Consider\u{a}m un HashSet \^{i}n care \c{t}inem cont de nodurile vizitate, un PriorityQueue din care extragem de fiecare dat\u{a} nodul cu $f\_cost$ minim \c{s}i o variabil\u{a} $found$ care devine true atunci c\^{a}nd nodul extras din coada cu priorit\u{a}\c{t}i coincide cu nodul destina\c{t}ie. Prima dat\u{a} introducem \^{i}n coada cu priorit\u{a}\c{t}i nodul surs\u{a}. At\^{a}ta timp c\^{a}t coada cu priorit\u{a}\c{t}i mai are elemente \c{s}i $found$ = false extragem nodul cu $f\_cost$ minim din PriorityQueue \c{s}i \^{i}l ad\u{a}ug\u{a}m \^{i}n lista cu noduri vizitate. De fiecare dat\u{a} c\^{a}nd extragem un nod din coada cu priorit\u{a}\c{t}i \^{i}i scriem numele \^{i}n fi\c{s}ier pentru a vizualiza la final ce ora\c{s}e au fost parcurse. Dac\u{a} nodul extras este chiar nodul destina\c{t}ie atunci variabila $found$ devine true. Pentru fiecare nod extras parcurgem lista sa de muchii. Calcul\u{a}m un nou cost g ca fiind costul g al nodului curent plus distan\c{t}a \^{i}ntre nodul curent \c{s}i nodul vecin \c{s}i un nou cost f ca fiind costul h al nodului vecin plus acest nou cost g. Dac\u{a} lista nodurilor vizitate con\c{t}ine nodul vecin \c{s}i noul cost f este mai mare sau egal dec\^{a}t costul f al nodului vecin atunci nu facem nimic. Altfel dac\u{a} coada cu priorit\u{a}\c{t}i nu con\c{t}ine nodul vecin sau noul cost f este mai mic dec\^{a}t costul f al nodului vecin, atunci nodul curent devine p\u{a}rintele nodului vecin \c{s}i actualiz\u{a}m costul g \c{s}i f al nodului vecin cu cele calculate anterior. \^{I}n cazul \^{i}n care coada cu priorit\u{a}\c{t}i con\c{t}ine acest nod vecin, atunci \^{i}l elimin\u{a}m din coad\u{a} pentru a evita existen\c{t}a sa de 2 ori. Apoi, indiferent dac\u{a} acesta era sau nu, ad\u{a}ug\u{a}m nodul \^{i}n coad\u{a}. La final, pentru a reconstitui calea pornim de la nodul destina\c{t}ie \c{s}i merg\^{a}nd din p\u{a}rinte \^{i}n p\u{a}rinte ajungem la nodul surs\u{a} \c{s}i determin\u{a}m calea pe care cei 2 prieteni se vor \^{i}nt\^{a}lni \^{i}n cel mai scurt timp. Func\c{t}ia returneaz\u{a} aceast\u{a} cale care va fi analizat\u{a} de urm\u{a}toarea func\c{t}ie pe care o voi prezenta.
    \item \^{I}n func\c{t}ia main din clasa Application se testeaz\u{a} func\c{t}iile discutate anterior de 10 ori, deoarece avem 10 fi\c{s}iere de input. De fiecare dat\u{a} se cite\c{s}te din fi\c{s}ierul de input num\u{a}rul de noduri \c{s}i de muchii \c{s}i se ini\c{t}ializeaz\u{a} variabilele $numberOfCities$ \c{s}i $numberOfRoads$ din RandomMapGenerator. Se scrie \^{i}n fi\c{s}ierul de output aceste 2 valori precum \c{s}i pozi\c{t}iile generate \^{i}n mod aleator ale celor 2 prieteni. Func\c{t}iei $bellmanFord$ oferim ca parametru ora\c{s}ul \^{i}n care se afl\u{a} cel de-al doilea prieten. Dup\u{a} ce algoritmul A* g\u{a}se\c{s}te calea pe care cei 2 prieteni se vor \^{i}nt\^{a}lni \^{i}n cel mai scurt timp, o scriem \^{i}n fi\c{s}ierul de output. Dup\u{a} ce se execut\u{a} func\c{t}ia $calculateTime$ se va scrie ora\c{s}ul \^{i}n care se vor \^{i}nt\^{a}lni \c{s}i timpul.
\end{itemize}

\section{Rezultate \c{s}i Concluzii}
\begin{itemize}
    \item[a.] Aceast\u{a} problem\u{a} de c\u{a}utare are ca \c{s}i scop s\u{a} a\c{s}ez\u{a}m cei 2 prieteni a \c{s}i b \^{i}n acela\c{s}i ora\c{s} i, \^{i}n cel mai scurt timp T posibil. Consider\u{a}m distan\c{t}a \^{i}n linie dreapt\u{a} \^{i}ntre dou\u{a} ora\c{s}e i \c{s}i j ca fiind dist(i, j). Starea ini\c{t}ial\u{a} a problemei este reprezentat\u{a} de perechea (i, j), unde i reprezint\u{a} ora\c{s}ul \^{i}n care se afl\u{a} primul prieten, iar j orasul \^{i}n care se afl\u{a} cel de-al doilea prieten. Starea final\u{a} a problemei este determinat\u{a} de perechea (i, i), ceea ce sugereaz\u{a} faptul c\u{a} cei 2 prieteni s-au \^{i}nt\^{a}lnit \^{i}n acela\c{s}i ora\c{s}, \^{i}ntr-un timp T care trebuie s\u{a} fie minim. Ac\c{t}iunile sunt determinate de mi\c{s}c\u{a}rile celor 2 prieteni \^{i}n unul din ora\c{s}ele vecine celui \^{i}n care se afl\u{a}. De exemplu, dac\u{a} primul se deplaseaz\u{a} \^{i}n i' \c{s}i al doilea in j', vom ad\u{a}uga la timpul T, max(dist(i, i'), dist(j,j')). Spa\c{t}iul st\u{a}rilor este determinat de mul\c{t}imea tuturor perechilor de ora\c{s}e (i, j). i \c{s}i j pot s\u{a} reprezinte acela\c{s}i ora\c{s} \^{i}n situa\c{t}ia \^{i}n care cei 2 prieteni s-au \^{i}nt\^{a}lnit.
    \item [b.] Am ales algoritmul A* deoarece este un algoritm euristic de explorare a grafului (\^{i}n aceast\u{a} situa\c{t}ie o hart\u{a} cu ora\c{s}e generat\u{a} \^{i}n mod aleator). Deoarece sunt oferite ca \c{s}i date de intrare pozi\c{t}iile celor 2 prieteni (ora\c{s}ele \^{i}n care ace\c{s}tia se afl\u{a}), putem considera c\u{a} aceste pozi\c{t}ii reprezint\u{a} o surs\u{a} \c{s}i o destina\c{t}ie pentru care aplic\u{a}m algoritmul A*. Acesta va afla calea de cost minim pe care cei doi prieteni se vor \^{i}nt\^{a}lni \^{i}n cel mai scurt timp. Dup\u{a} ce am aflat calea, cei 2 prieteni se deplaseaz\u{a} simultan, unul spre cel\u{a}lalt.
\end{itemize}

\^{I}n tabelul urm\u{a}tor este pus\u{a} \^{i}n eviden\c{t}\u{a} evolu\c{t}ia din perspectiva timpului de execu\c{t}ie at\^{a}t a algoritmului A* c\^{a}t \c{s}i a \^{i}ntregului program pe seturi de date de dimensiuni din ce \^{i}n ce mai mari. Se observ\u{a} c\u{a} timpul de execu\c{t}ie al algoritmului A* este extrem de mic. Acest lucru se datoreaz\u{a} func\c{t}iei euristice de aproximare a distan\c{t}ei minime a fiec\u{a}rui nod p\^{a}n\u{a} la nodul destina\c{t}ie, astfel \^{i}nc\^{a}t se evit\u{a} parcurgerea anumitor c\u{a}i pe care ne \^{i}ndep\u{a}rt\u{a}m de destina\c{t}ia noastr\u{a}.
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
    \hline
    Nr & Num\u{a}rul de noduri & Num\u{a}rul de muchii & A* & \^{I}ntreg programul \\
    \hline
    1 & 500 & 2500 & 0.002 s & 0.48 s  \\
    \hline
    2 & 750 & 4000 & 0 s & 0.18 s \\
    \hline
    3 & 1000 & 5000 & 0 s & 0.089 s \\
    \hline
    4 & 1500 & 7500 & 0.001 s & 0.219 s \\
    \hline
    5 & 2000 & 10000 & 0 s & 0.435 s \\
    \hline
    6 & 2500 & 12500 & 0.001 s & 0.490 s \\
    \hline
    7 & 3000 & 15000 & 0.001 s & 0.554 s \\
    \hline
    8 & 4000 & 20000 & 0.001 s & 1.471 s \\
    \hline
    9 & 5000 & 25000 & 0.002 s & 2.057 s \\
    \hline
    10 & 10000 & 30000 & 0.001 s & 4.553 s \\
    \hline
\end{tabular}
\end{center}


\begin{thebibliography}{9}
    
    \bibitem{latex}
     \LaTeX~project site,
     \url{http://latex-project.org/}
    
    \bibitem{latex2}
     \url{https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes}
     
    \bibitem{aima2010}
	  Stuart Russell and Peter Norvig,
	  \emph{Artificial Intelligence: A Modern Approach}.
	  Prentice Hall,
	  3rd Edition,
	  2010,
	  pp. 96-101.
	  
	\bibitem{Algoritmul A*}
	 \url{https://en.wikipedia.org/wiki/A*_search_algorithm}
	
	\bibitem{JavaFaker1}
	 \url{https://www.baeldung.com/java-faker}
	 
	\bibitem{JavaFaker2}
	 \url{https://github.com/DiUS/java-faker}
	 
	\bibitem{A*}
	 \url{https://dzone.com/articles/from-dijkstra-to-a-star-a-part-2-the-a-star-a-algo}
	 
	 \bibitem{Bellman-Ford}
	  \url{https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm}
 
\end{thebibliography}


\end{document}
